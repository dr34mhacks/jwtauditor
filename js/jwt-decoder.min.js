class JWTDecoder{constructor(){this.token=null;this.header=null;this.payload=null;this.signature=null;this.parts=[]}validateJWTFormat(a){if(!a)throw new Error('JWT token is required');a=a.trim();if(!a)throw new Error('JWT token cannot be empty');if(a.startsWith('http')||a.includes('://')||a.includes('www.')||a.includes('.com')||a.includes('.org')||a.includes('.net'))throw new Error('URLs are not valid JWT tokens');if(a.includes(' ')&&a.split(' ').length>3)throw new Error('Invalid input: This appears to be text, not a JWT token');if(a.length<30)throw new Error('Invalid JWT: Token too short to be a valid JWT');if(!a.includes('.'))throw new Error('Invalid JWT format: Token must contain dots as separators');const b=a.split('.');if(b.length!==3)throw new Error(`Invalid JWT format: Expected 3 parts separated by dots, got ${b.length} parts`);for(let c=0;c<2;c++){if(!b[c]||b[c].trim()==='')throw new Error(`Invalid JWT format: ${['header','payload'][c]} part cannot be empty`);this.detectMaliciousPayloads(b[c]);if(!/^[A-Za-z0-9_-]+$/.test(b[c]))throw new Error(`Invalid JWT format: ${['header','payload'][c]} contains invalid base64url characters`)}if(b[2]){this.detectMaliciousPayloads(b[2]);if(!/^[A-Za-z0-9_-]+$/.test(b[2]))throw new Error('Invalid JWT format: signature contains invalid base64url characters')}return{token:a,parts:b,hasSignature:!!(b[2]&&b[2].length>0)}}detectMaliciousPayloads(a){if(!a||a.length===0)return;const b=[/\{\{.*?\}\}/g,/\$\{.*?\}/g,/<script[^>]*>.*?<\/script>/gi,/<.*?on\w+\s*=.*?>/gi,/javascript:/gi,/data:text\/html/gi,/vbscript:/gi,/expression\s*\(/gi,/union\s+select/gi,/drop\s+table/gi,/insert\s+into/gi,/delete\s+from/gi,/update\s+set/gi,/exec\s*\(/gi,/eval\s*\(/gi,/system\s*\(/gi,/cmd\s*\(/gi,/shell_exec/gi,/passthru/gi,/\0/g];const c=['template injection','expression injection','XSS script tag','XSS event handler','javascript protocol','data URI','vbscript protocol','CSS expression','SQL union','SQL drop','SQL insert','SQL delete','SQL update','command execution','eval injection','system command','cmd execution','shell execution','passthru','null byte'];for(let d=0;d<b.length;d++){if(b[d].test(a)){throw new Error(`Security violation: Detected potential ${c[d]} attack pattern in JWT token`)}}if(a.includes('../..')||a.includes('..\\..\\')){ throw new Error('Security violation: Detected potential path traversal attack pattern in JWT token')}const e=a.toLowerCase();if(e.includes('alert(')||e.includes('prompt(')||e.includes('confirm(')||e.includes('document.cookie')||e.includes('window.location')||e.includes('document.write')||e.includes('innerHTML')||e.includes('outerhtml')||e.includes('function(')||e.includes('settimeout')||e.includes('setinterval')||e.includes('xmlhttprequest')||e.includes('fetch(')||e.includes('import(')||e.includes('require(')){throw new Error('Security violation: Detected potential XSS or code injection patterns in JWT token')}if(e.includes('file://')||e.includes('ftp://')||e.includes('gopher://')||e.includes('ldap://')||e.includes('dict://')||e.includes('sftp://')||e.includes('tftp://')||e.includes('telnet://')){throw new Error('Security violation: Detected potential SSRF attack patterns in JWT token')}}decode(a){try{const{token:b,parts:c,hasSignature:hasSig}=this.validateJWTFormat(a);if(!hasSig){showNotification('Warning: JWT has no signature - this token is not secure and can be easily tampered with','warning',5000)}let d,e;try{d=base64UrlDecode(c[0])}catch(f){throw new Error(`Failed to decode JWT header: ${f.message}`)}try{e=base64UrlDecode(c[1])}catch(f){throw new Error(`Failed to decode JWT payload: ${f.message}`)}let g,h;try{g=JSON.parse(d)}catch(f){throw new Error(`Invalid JWT header: Header is not valid JSON - ${f.message}`)}try{h=JSON.parse(e)}catch(f){throw new Error(`Invalid JWT payload: Payload is not valid JSON - ${f.message}`)}if(!g||typeof g!=='object')throw new Error('Invalid JWT: Header must be a valid JSON object');if(!g.alg)throw new Error('Invalid JWT: Header must contain "alg" (algorithm) field');const i=['HS256','HS384','HS512','RS256','RS384','RS512','ES256','ES384','ES512','PS256','PS384','PS512','none'];if(!i.includes(g.alg))throw new Error(`Invalid JWT: Unsupported algorithm "${g.alg}". Supported algorithms: ${i.join(', ')}`);if(g.typ&&g.typ!=='JWT')throw new Error(`Invalid JWT: Token type "${g.typ}" is not supported. Expected "JWT"`);if(!h||typeof h!=='object')throw new Error('Invalid JWT: Payload must be a valid JSON object');const j=['iat','exp','nbf'];for(const k of j){if(h[k]!==undefined&&(typeof h[k]!=='number'||h[k]<0))throw new Error(`Invalid JWT: "${k}" claim must be a positive number (Unix timestamp)`)}if(h.iat&&h.exp&&h.iat>h.exp)throw new Error('Invalid JWT: "iat" (issued at) cannot be after "exp" (expiration time)');if(h.nbf&&h.exp&&h.nbf>h.exp)throw new Error('Invalid JWT: "nbf" (not before) cannot be after "exp" (expiration time)');this.token=b;this.parts=c;this.header=g;this.payload=h;this.signature=c[2]||'';return{header:this.header,payload:this.payload,signature:this.signature,raw:{header:c[0],payload:c[1],signature:c[2]||''}}}catch(b){this.token=null;this.header=null;this.payload=null;this.signature=null;this.parts=[];throw b}}isExpired(){if(!this.payload||!this.payload.exp)return!1;return isExpired(this.payload.exp)}getTimeUntilExpiration(){if(!this.payload||!this.payload.exp)return'No expiration';return timeUntilExpiration(this.payload.exp)}isValidForUse(){if(!this.payload)return!1;const a=getCurrentTimestamp();if(this.payload.exp&&this.payload.exp<a)return!1;if(this.payload.nbf&&this.payload.nbf>a)return!1;return!0}getFormattedPayload(){if(!this.payload)return null;const a={...this.payload},b=['exp','iat','nbf'];for(const c of b){if(a[c]&&typeof a[c]==='number'){a[`${c}_formatted`]=formatTimestamp(a[c])}}return a}getAlgorithm(){return this.header?this.header.alg:null}usesNoneAlgorithm(){return this.getAlgorithm()==='none'}usesSymmetricAlgorithm(){const a=this.getAlgorithm();return a&&a.startsWith('HS')}usesAsymmetricAlgorithm(){const a=this.getAlgorithm();return a&&(a.startsWith('RS')||a.startsWith('ES')||a.startsWith('PS'))}getSigningInput(){if(!this.parts||this.parts.length<2)return'';return`${this.parts[0]}.${this.parts[1]}`}async verifySignature(a){if(!this.token)return!1;try{const b=this.getAlgorithm();if(b==='none')return!0;if(!b.startsWith('HS'))throw new Error(`Algorithm ${b} not supported in fallback mode`);const c=this.getSigningInput(),d=await computeHmac(b,a,c),e=d.replace(/\+/g,'-').replace(/\//g,'_').replace(/=/g,'');return e===this.signature}catch(b){console.error('Error verifying signature:',b);return!1}}}const jwtDecoder=new JWTDecoder;