class JWTDecoder{constructor(){this.token=null;this.header=null;this.payload=null;this.signature=null;this.parts=[]}validateJWTFormat(a){if(!a)throw new Error('JWT token is required');a=a.trim();if(!a)throw new Error('JWT token cannot be empty');if(a.startsWith('http')||a.includes('://')||a.includes('www.')||a.includes('.com')||a.includes('.org')||a.includes('.net'))throw new Error('URLs are not valid JWT tokens');if(a.includes(' ')&&a.split(' ').length>3)throw new Error('Invalid input: This appears to be text, not a JWT token');if(a.length<30)throw new Error('Invalid JWT: Token too short to be a valid JWT');if(!a.includes('.'))throw new Error('Invalid JWT format: Token must contain dots as separators');const b=a.split('.');if(b.length!==3)throw new Error(`Invalid JWT format: Expected 3 parts separated by dots, got ${b.length} parts`);for(let c=0;c<2;c++){if(!b[c]||b[c].trim()==='')throw new Error(`Invalid JWT format: ${['header','payload'][c]} part cannot be empty`);if(!/^[A-Za-z0-9_-]+$/.test(b[c]))throw new Error(`Invalid JWT format: ${['header','payload'][c]} contains invalid base64url characters`)}if(b[2]&&!/^[A-Za-z0-9_-]*$/.test(b[2]))throw new Error('Invalid JWT format: signature contains invalid base64url characters');return{token:a,parts:b,hasSignature:!!(b[2]&&b[2].length>0)}}decode(a){try{const{token:b,parts:c,hasSignature:hasSig}=this.validateJWTFormat(a);if(!hasSig){showNotification('Warning: JWT has no signature - this token is not secure and can be easily tampered with','warning',5000)}let d,e;try{d=base64UrlDecode(c[0])}catch(f){throw new Error(`Failed to decode JWT header: ${f.message}`)}try{e=base64UrlDecode(c[1])}catch(f){throw new Error(`Failed to decode JWT payload: ${f.message}`)}let g,h;try{g=JSON.parse(d)}catch(f){throw new Error(`Invalid JWT header: Header is not valid JSON - ${f.message}`)}try{h=JSON.parse(e)}catch(f){throw new Error(`Invalid JWT payload: Payload is not valid JSON - ${f.message}`)}if(!g||typeof g!=='object')throw new Error('Invalid JWT: Header must be a valid JSON object');if(!g.alg)throw new Error('Invalid JWT: Header must contain "alg" (algorithm) field');const i=['HS256','HS384','HS512','RS256','RS384','RS512','ES256','ES384','ES512','PS256','PS384','PS512','none'];if(!i.includes(g.alg))throw new Error(`Invalid JWT: Unsupported algorithm "${g.alg}". Supported algorithms: ${i.join(', ')}`);if(g.typ&&g.typ!=='JWT')throw new Error(`Invalid JWT: Token type "${g.typ}" is not supported. Expected "JWT"`);if(!h||typeof h!=='object')throw new Error('Invalid JWT: Payload must be a valid JSON object');const j=['iat','exp','nbf'];for(const k of j){if(h[k]!==undefined&&(typeof h[k]!=='number'||h[k]<0))throw new Error(`Invalid JWT: "${k}" claim must be a positive number (Unix timestamp)`)}if(h.iat&&h.exp&&h.iat>h.exp)throw new Error('Invalid JWT: "iat" (issued at) cannot be after "exp" (expiration time)');if(h.nbf&&h.exp&&h.nbf>h.exp)throw new Error('Invalid JWT: "nbf" (not before) cannot be after "exp" (expiration time)');this.token=b;this.parts=c;this.header=g;this.payload=h;this.signature=c[2]||'';return{header:this.header,payload:this.payload,signature:this.signature,raw:{header:c[0],payload:c[1],signature:c[2]||''}}}catch(b){this.token=null;this.header=null;this.payload=null;this.signature=null;this.parts=[];throw b}}isExpired(){if(!this.payload||!this.payload.exp)return!1;return isExpired(this.payload.exp)}getTimeUntilExpiration(){if(!this.payload||!this.payload.exp)return'No expiration';return timeUntilExpiration(this.payload.exp)}isValidForUse(){if(!this.payload)return!1;const a=getCurrentTimestamp();if(this.payload.exp&&this.payload.exp<a)return!1;if(this.payload.nbf&&this.payload.nbf>a)return!1;return!0}getFormattedPayload(){if(!this.payload)return null;const a={...this.payload},b=['exp','iat','nbf'];for(const c of b){if(a[c]&&typeof a[c]==='number'){a[`${c}_formatted`]=formatTimestamp(a[c])}}return a}getAlgorithm(){return this.header?this.header.alg:null}usesNoneAlgorithm(){return this.getAlgorithm()==='none'}usesSymmetricAlgorithm(){const a=this.getAlgorithm();return a&&a.startsWith('HS')}usesAsymmetricAlgorithm(){const a=this.getAlgorithm();return a&&(a.startsWith('RS')||a.startsWith('ES')||a.startsWith('PS'))}getSigningInput(){if(!this.parts||this.parts.length<2)return'';return`${this.parts[0]}.${this.parts[1]}`}async verifySignature(a){if(!this.token)return!1;try{const b=this.getAlgorithm();if(b==='none')return!0;if(!b.startsWith('HS'))throw new Error(`Algorithm ${b} not supported in fallback mode`);const c=this.getSigningInput(),d=await computeHmac(b,a,c),e=d.replace(/\+/g,'-').replace(/\//g,'_').replace(/=/g,'');return e===this.signature}catch(b){console.error('Error verifying signature:',b);return!1}}}const jwtDecoder=new JWTDecoder;