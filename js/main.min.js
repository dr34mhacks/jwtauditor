document.addEventListener('DOMContentLoaded', () => {
    if (!isWasmSupported()) {
        showNotification('WebAssembly is not supported in this browser. Some features may not work correctly.', 'warning', 5000);
    }
    
    initTabs();
    initDecoderTab();
    initBruteforceTab();
    initEditorTab();
    initGeneratorTab();
});

function initTabs() {
    const tabButtons = document.querySelectorAll('.tab-btn');
    const tabPanes = document.querySelectorAll('.tab-pane');
    
    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            const tabId = button.getAttribute('data-tab');
            
            tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            
            tabPanes.forEach(pane => pane.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
        });
    });
}

function initDecoderTab() {
    const jwtInput = document.getElementById('jwt-input');
    const decodeBtn = document.getElementById('decode-btn');
    const generateRandomJwtBtn = document.getElementById('generate-random-jwt-btn');
    const headerOutput = document.getElementById('header-output');
    const payloadOutput = document.getElementById('payload-output');
    const signatureOutput = document.getElementById('signature-output');
    const securityAnalysis = document.getElementById('security-analysis');
    
    generateRandomJwtBtn.addEventListener('click', () => {
        try {
            jwtGenerator.resetToDefaults();
            
            const randomSecret = 'random-secret-' + Math.random().toString(36).substring(2, 15);
            const randomJwt = jwtGenerator.generateToken('HS256', randomSecret);
            
            jwtInput.value = randomJwt;
            
            decodeBtn.click();
            
            showNotification('Random JWT generated and analyzed successfully', 'success');
        } catch (error) {
            showNotification(`Error generating random JWT: ${error.message}`, 'error');
        }
    });
    
    decodeBtn.addEventListener('click', () => {
        const token = jwtInput.value.trim();
        
        if (!token) {
            showNotification('Please enter a JWT token', 'warning');
            return;
        }
        
        try {
            const decoded = jwtDecoder.decode(token);
            
            headerOutput.innerHTML = formatJSON(decoded.header);
            payloadOutput.innerHTML = formatJSON(decoded.payload);
            signatureOutput.textContent = decoded.signature;
            
            const vulnerabilities = jwtAnalyzer.analyze(token);
            securityAnalysis.innerHTML = jwtAnalyzer.getVulnerabilitiesHTML();
            
            // Remove any existing action section first to prevent duplicates
            const existingActionSection = document.querySelector('.analysis-actions');
            if (existingActionSection) {
                existingActionSection.remove();
            }
            
            setTimeout(() => {
                const bruteforceLinks = document.querySelectorAll('.vulnerability a[href="#bruteforce"], .vulnerability-card a[href="#bruteforce"], .test-btn');
                bruteforceLinks.forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        
                        const bruteforceTab = document.querySelector('.tab-btn[data-tab="bruteforce"]');
                        bruteforceTab.click();
                        
                        const bruteforceInput = document.getElementById('bruteforce-jwt-input');
                        bruteforceInput.value = token;
                        
                        showNotification('Token copied to Bruteforce tab', 'info');
                    });
                });
                
                if (jwtDecoder.usesSymmetricAlgorithm()) {
                    const actionSection = document.createElement('div');
                    actionSection.className = 'analysis-actions';
                    actionSection.innerHTML = `
                        <button id="try-bruteforce-btn" class="primary-btn">
                            <i class="fas fa-key"></i> Test for Weak Secret
                        </button>
                        <p class="action-hint">This token uses a symmetric algorithm (HS*) and could be tested for weak secrets</p>
                    `;
                    
                    securityAnalysis.parentNode.insertBefore(actionSection, securityAnalysis.nextSibling);
                    
                    document.getElementById('try-bruteforce-btn').addEventListener('click', () => {
                        const bruteforceTab = document.querySelector('.tab-btn[data-tab="bruteforce"]');
                        bruteforceTab.click();
                        
                        const bruteforceInput = document.getElementById('bruteforce-jwt-input');
                        bruteforceInput.value = token;
                        
                        showNotification('Token copied to Bruteforce tab', 'info');
                    });
                }
            }, 100);
            
            showNotification('JWT decoded and analyzed successfully', 'success');
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
            
            headerOutput.innerHTML = '';
            payloadOutput.innerHTML = '';
            signatureOutput.textContent = '';
            securityAnalysis.innerHTML = '';
            
            const actionSection = document.querySelector('.analysis-actions');
            if (actionSection) {
                actionSection.remove();
            }
        }
    });
}

function initBruteforceTab() {
    const jwtInput = document.getElementById('bruteforce-jwt-input');
    const methodRadios = document.querySelectorAll('input[name="bruteforce-method"]');
    const customWordlistContainer = document.getElementById('custom-wordlist-container');
    const customWordlist = document.getElementById('custom-wordlist');
    const wordlistFile = document.getElementById('wordlist-file');
    const fileName = document.getElementById('file-name');
    const startBtn = document.getElementById('start-bruteforce-btn');
    const stopBtn = document.getElementById('stop-bruteforce-btn');
    const progressBar = document.getElementById('bruteforce-progress');
    const progressText = document.getElementById('progress-text');
    const statusText = document.getElementById('bruteforce-status');
    const resultText = document.getElementById('bruteforce-result');
    const bruteforceOptions = document.getElementById('bruteforce-options');
    const bruteforceWarning = document.getElementById('bruteforce-warning');
    
    jwtInput.addEventListener('input', () => {
        const token = jwtInput.value.trim();
        
        if (token) {
            try {
                const decoded = jwtDecoder.decode(token);
                const alg = decoded.header.alg;
                
                if (bruteforceWarning) {
                    bruteforceWarning.innerHTML = '';
                    bruteforceWarning.style.display = 'none';
                }
                
                if (alg !== 'none' && !alg.startsWith('HS')) {
                    if (bruteforceWarning) {
                        bruteforceWarning.innerHTML = `
                            <div class="warning-box">
                                <i class="fas fa-exclamation-triangle warning-icon"></i>
                                <div class="warning-content">
                                    <strong>Non-HMAC Algorithm Detected: ${alg}</strong>
                                    <p>This token uses ${alg}, which cannot be bruteforced using this method.</p>
                                    <p>Only HMAC algorithms (HS256, HS384, HS512) can be bruteforced because they use a shared secret key.</p>
                                    <p>${alg} uses asymmetric cryptography with public/private key pairs, which cannot be bruteforced.</p>
                                    <p><a href="docs/tool-guides/secret-bruteforcer.html#limitations" target="_blank">Learn more about algorithm limitations</a></p>
                                </div>
                            </div>
                        `;
                        bruteforceWarning.style.display = 'block';
                        startBtn.disabled = true;
                    }
                } else {
                    startBtn.disabled = false;
                }
            } catch (error) {
                if (bruteforceWarning) {
                    bruteforceWarning.innerHTML = '';
                    bruteforceWarning.style.display = 'none';
                }
            }
        } else {
            if (bruteforceWarning) {
                bruteforceWarning.innerHTML = '';
                bruteforceWarning.style.display = 'none';
            }
        }
    });
    
    methodRadios.forEach(radio => {
        radio.addEventListener('change', () => {
            if (radio.value === 'custom') {
                customWordlistContainer.style.display = 'block';
                document.getElementById('dictionary-description').style.display = 'none';
                document.getElementById('custom-description').style.display = 'block';
            } else {
                customWordlistContainer.style.display = 'none';
                document.getElementById('dictionary-description').style.display = 'block';
                document.getElementById('custom-description').style.display = 'none';
            }
        });
    });
    
    wordlistFile.addEventListener('change', (event) => {
        const file = event.target.files[0];
        
        if (file) {
            fileName.textContent = file.name;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                customWordlist.value = e.target.result;
            };
            reader.readAsText(file);
        } else {
            fileName.textContent = '';
        }
    });
    
    startBtn.addEventListener('click', async () => {
        const token = jwtInput.value.trim();
        
        if (!token) {
            showNotification('Please enter a JWT token', 'warning');
            return;
        }
        
        try {
            const decoded = jwtDecoder.decode(token);
            const alg = decoded.header.alg;
            
            if (alg !== 'none' && !alg.startsWith('HS')) {
                if (bruteforceWarning) {
                    bruteforceWarning.innerHTML = `
                        <div class="warning-box">
                            <i class="fas fa-exclamation-triangle warning-icon"></i>
                            <div class="warning-content">
                                <strong>Non-HMAC Algorithm Detected: ${alg}</strong>
                                <p>This token uses ${alg}, which cannot be bruteforced using this method.</p>
                                <p>Only HMAC algorithms (HS256, HS384, HS512) can be bruteforced because they use a shared secret key.</p>
                                <p>${alg} uses asymmetric cryptography with public/private key pairs, which cannot be bruteforced.</p>
                                <p><a href="docs/tool-guides/secret-bruteforcer.html#limitations" target="_blank">Learn more about algorithm limitations</a></p>
                            </div>
                        </div>
                    `;
                    bruteforceWarning.style.display = 'block';
                }
                
                showNotification(`Cannot bruteforce: Algorithm ${alg} not supported for bruteforcing`, 'warning');
                return;
            }
        } catch (error) {
            // Continue with bruteforcing attempt if token format is invalid
        }
        
        const method = document.querySelector('input[name="bruteforce-method"]:checked').value;
        
        if (!jwtBruteforcer.init(token)) {
            if (jwtBruteforcer.nonHmacAlgorithmDetected) {
                const alg = jwtBruteforcer.detectedAlgorithm;
                
                statusText.textContent = `Cannot bruteforce: Algorithm ${alg} not supported`;
                resultText.innerHTML = `
                    <div class="warning-box">
                        <i class="fas fa-exclamation-triangle warning-icon"></i>
                        <div class="warning-content">
                            <strong>Non-HMAC Algorithm Detected: ${alg}</strong>
                            <p>This token uses ${alg}, which cannot be bruteforced using this method.</p>
                            <p>Only HMAC algorithms (HS256, HS384, HS512) can be bruteforced because they use a shared secret key.</p>
                            <p>${alg} uses asymmetric cryptography with public/private key pairs, which cannot be bruteforced.</p>
                            <p><a href="docs/tool-guides/secret-bruteforcer.html#limitations" target="_blank">Learn more about algorithm limitations</a></p>
                        </div>
                    </div>
                `;
                resultText.style.display = 'block';
                
                showNotification(`Cannot bruteforce: Algorithm ${alg} not supported for bruteforcing`, 'warning');
            } else {
                showNotification('Failed to initialize bruteforcer. Check if the token is valid.', 'error');
            }
            return;
        }
        
        if (method === 'custom') {
            if (!customWordlist.value.trim()) {
                showNotification('Please enter a custom wordlist', 'warning');
                return;
            }
            
            jwtBruteforcer.setCustomWordlist(customWordlist.value);
        }
        
        startBtn.disabled = true;
        stopBtn.disabled = false;
        progressBar.style.width = '0%';
        progressText.textContent = '0%';
        statusText.textContent = 'Bruteforcing in progress...';
        resultText.style.display = 'none';
        resultText.textContent = '';
        
        jwtBruteforcer.start(
            method,
            (progress) => {
                progressBar.style.width = `${progress}%`;
                progressText.textContent = `${progress}%`;
            },
            (result) => {
                if (result.success) {
                    statusText.textContent = 'Secret found!';
                    resultText.textContent = `Secret: ${result.secret}`;
                    resultText.style.display = 'block';
                    showNotification('Secret found!', 'success');
                } else {
                    statusText.textContent = result.error || 'No matching secret found in the wordlist.';
                    showNotification('Bruteforce completed without finding a match', 'info');
                }
                
                startBtn.disabled = false;
                stopBtn.disabled = true;
            }
        );
    });
    
    stopBtn.addEventListener('click', () => {
        jwtBruteforcer.stop();
        statusText.textContent = 'Bruteforce stopped by user.';
        startBtn.disabled = false;
        stopBtn.disabled = true;
        showNotification('Bruteforce stopped', 'info');
    });
}

function initEditorTab() {
    const jwtInput = document.getElementById('editor-jwt-input');
    const loadBtn = document.getElementById('load-jwt-btn');
    const headerEditor = document.getElementById('header-editor');
    const payloadEditor = document.getElementById('payload-editor');
    const algorithmSelect = document.getElementById('signature-algorithm');
    const secretKeyContainer = document.getElementById('secret-key-container');
    const rsaKeyContainer = document.getElementById('rsa-key-container');
    const secretKey = document.getElementById('secret-key');
    const privateKey = document.getElementById('private-key');
    const generateBtn = document.getElementById('generate-edited-jwt-btn');
    const copyBtn = document.getElementById('copy-edited-jwt-btn');
    const outputJwt = document.getElementById('edited-jwt-output');
    
    algorithmSelect.addEventListener('change', () => {
        const algorithm = algorithmSelect.value;
        
        if (algorithm === 'none') {
            secretKeyContainer.style.display = 'none';
            rsaKeyContainer.style.display = 'none';
        } else if (algorithm.startsWith('HS')) {
            secretKeyContainer.style.display = 'block';
            rsaKeyContainer.style.display = 'none';
        } else if (algorithm.startsWith('RS')) {
            secretKeyContainer.style.display = 'none';
            rsaKeyContainer.style.display = 'block';
        }
    });
    
    loadBtn.addEventListener('click', () => {
        const token = jwtInput.value.trim();
        
        if (!token) {
            showNotification('Please enter a JWT token', 'warning');
            return;
        }
        
        try {
            const decoded = jwtEditor.loadToken(token);
            
            headerEditor.value = jwtEditor.getFormattedHeader();
            payloadEditor.value = jwtEditor.getFormattedPayload();
            
            algorithmSelect.value = decoded.header.alg || 'HS256';
            algorithmSelect.dispatchEvent(new Event('change'));
            
            showNotification('JWT loaded successfully', 'success');
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        }
    });
    
    generateBtn.addEventListener('click', () => {
        try {
            jwtEditor.updateHeader(headerEditor.value);
            jwtEditor.updatePayload(payloadEditor.value);
            
            const algorithm = algorithmSelect.value;
            
            let token;
            if (algorithm === 'none') {
                token = jwtEditor.generateNoneToken();
            } else if (algorithm.startsWith('HS')) {
                if (!secretKey.value) {
                    showNotification('Please enter a secret key', 'warning');
                    return;
                }
                token = jwtEditor.generateSymmetricToken(algorithm, secretKey.value);
            } else if (algorithm.startsWith('RS')) {
                if (!privateKey.value) {
                    showNotification('Please enter a private key', 'warning');
                    return;
                }
                token = jwtEditor.generateAsymmetricToken(algorithm, privateKey.value);
            }
            
            outputJwt.textContent = token;
            
            showNotification('JWT generated successfully', 'success');
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        }
    });
    
    copyBtn.addEventListener('click', async () => {
        const token = outputJwt.textContent;
        
        if (!token) {
            showNotification('No JWT to copy', 'warning');
            return;
        }
        
        try {
            await copyToClipboard(token);
            showNotification('JWT copied to clipboard', 'success');
        } catch (error) {
            showNotification('Failed to copy to clipboard', 'error');
        }
    });
}

function initGeneratorTab() {
    const headerEditor = document.getElementById('generator-header');
    const payloadEditor = document.getElementById('generator-payload');
    const claimButtons = document.querySelectorAll('.claim-btn');
    const algorithmSelect = document.getElementById('generator-algorithm');
    const secretKeyContainer = document.getElementById('generator-secret-key-container');
    const rsaKeyContainer = document.getElementById('generator-rsa-key-container');
    const secretKey = document.getElementById('generator-secret-key');
    const privateKey = document.getElementById('generator-private-key');
    const publicKey = document.getElementById('generator-public-key');
    const publicKeyDisplay = document.getElementById('public-key-display');
    const generateRsaKeysBtn = document.getElementById('generate-rsa-keys-btn');
    const generateBtn = document.getElementById('generate-new-jwt-btn');
    const copyBtn = document.getElementById('copy-new-jwt-btn');
    const outputJwt = document.getElementById('generated-jwt-output');
    
    jwtGenerator.resetToDefaults();
    headerEditor.value = jwtGenerator.getFormattedHeader();
    payloadEditor.value = jwtGenerator.getFormattedPayload();
    
    algorithmSelect.addEventListener('change', () => {
        const algorithm = algorithmSelect.value;
        
        if (algorithm === 'none') {
            secretKeyContainer.style.display = 'none';
            rsaKeyContainer.style.display = 'none';
        } else if (algorithm.startsWith('HS')) {
            secretKeyContainer.style.display = 'block';
            rsaKeyContainer.style.display = 'none';
        } else if (algorithm.startsWith('RS')) {
            secretKeyContainer.style.display = 'none';
            rsaKeyContainer.style.display = 'block';
        }
    });
    
    generateRsaKeysBtn.addEventListener('click', async () => {
        try {
            showNotification('Generating RSA key pair...', 'info', 2000);
            
            const keyPair = await generateRSAKeyPair(2048);
            
            privateKey.value = keyPair.privateKey;
            publicKey.value = keyPair.publicKey;
            
            publicKeyDisplay.style.display = 'block';
            
            showNotification('RSA key pair generated successfully!', 'success');
        } catch (error) {
            console.error('Error generating RSA key pair:', error);
            showNotification(`Error: ${error.message}`, 'error');
        }
    });
    
    claimButtons.forEach(button => {
        button.addEventListener('click', () => {
            const claimName = button.getAttribute('data-claim');
            
            try {
                jwtGenerator.setPayload(payloadEditor.value);
                
                if (jwtGenerator.addClaim(claimName)) {
                    payloadEditor.value = jwtGenerator.getFormattedPayload();
                    showNotification(`Added ${claimName} claim`, 'success');
                } else {
                    showNotification(`Claim ${claimName} already exists`, 'info');
                }
            } catch (error) {
                showNotification(`Error: ${error.message}`, 'error');
            }
        });
    });
    
    generateBtn.addEventListener('click', () => {
        try {
            jwtGenerator.setHeader(headerEditor.value);
            jwtGenerator.setPayload(payloadEditor.value);
            
            jwtGenerator.updateTimestamps();
            
            const algorithm = algorithmSelect.value;
            
            let token;
            if (algorithm === 'none') {
                token = jwtGenerator.generateToken('none');
            } else if (algorithm.startsWith('HS')) {
                if (!secretKey.value) {
                    showNotification('Please enter a secret key', 'warning');
                    return;
                }
                token = jwtGenerator.generateToken(algorithm, secretKey.value);
            } else if (algorithm.startsWith('RS')) {
                if (!privateKey.value) {
                    showNotification('Please enter a private key', 'warning');
                    return;
                }
                token = jwtGenerator.generateToken(algorithm, '', privateKey.value);
            }
            
            outputJwt.textContent = token;
            
            payloadEditor.value = jwtGenerator.getFormattedPayload();
            
            showNotification('JWT generated successfully', 'success');
        } catch (error) {
            console.error('JWT Generation Error:', error);
            showNotification(`Error: ${error.message}`, 'error');
        }
    });
    
    copyBtn.addEventListener('click', async () => {
        const token = outputJwt.textContent;
        
        if (!token) {
            showNotification('No JWT to copy', 'warning');
            return;
        }
        
        try {
            await copyToClipboard(token);
            showNotification('JWT copied to clipboard', 'success');
        } catch (error) {
            showNotification('Failed to copy to clipboard', 'error');
        }
    });
}